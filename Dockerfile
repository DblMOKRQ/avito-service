# --- Стадия 1: Сборка приложения ---
# Используем официальный образ Go как основу для сборки.
# Версия 'alpine' является легковесной.
FROM golang:1.25.3-alpine AS builder

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем файлы зависимостей
# Это позволяет Docker кешировать слой с зависимостями, ускоряя последующие сборки,
# если go.mod и go.sum не изменились.
COPY go.mod go.sum ./
RUN go mod download

# Копируем весь исходный код проекта
COPY . .

# Собираем приложение.
# CGO_ENABLED=0 создает статически скомпилированный бинарный файл без C-зависимостей.
# -o /app/server - указывает, куда положить скомпилированный файл.
# ИСПРАВЛЕНИЕ: Вместо './cmd/api' указываем '.', так как main.go находится в корне.
RUN CGO_ENABLED=0 go build -o /app/server ./cmd/

# --- Стадия 2: Финальный образ ---
# Используем минимальный базовый образ Alpine. Он очень маленький и безопасный.
FROM alpine:latest

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем скомпилированный бинарный файл из стадии сборки.
COPY --from=builder /app/server .

# Копируем папку с миграциями. Ваше приложение читает их из файловой системы при запуске.
COPY ./migrations ./migrations

# Открываем порт, на котором будет работать наш сервис.
EXPOSE 8080

# Команда, которая будет выполняться при запуске контейнера.
# Запускаем наш скомпилированный сервер.
CMD ["/app/server"]